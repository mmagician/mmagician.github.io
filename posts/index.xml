<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Hungry Cats Studio</title><link>https://HungryCatsStudio.github.io/posts/</link><description>Recent content in Posts on Hungry Cats Studio</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 20 Oct 2023 11:03:00 +0200</lastBuildDate><atom:link href="https://HungryCatsStudio.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Need for Speed: efficient multilinear PCS in Lasso and Jolt</title><link>https://HungryCatsStudio.github.io/posts/lookups-ml-pcs/</link><pubDate>Fri, 20 Oct 2023 11:03:00 +0200</pubDate><guid>https://HungryCatsStudio.github.io/posts/lookups-ml-pcs/</guid><description>Problem statement In this write-up, we aim to provide context for the Need for Speed: why do we need efficient (multilinear) polynomial commitment schemes for lookups, specifically in the context of Lasso and Jolt.
To put the problem into context, we first motivate the need for Lasso, and lookups in general, with an example. We then briefly describe the non-trivial marriage of lookup arguments with general SNARKs for R1CS. To complete the big picture, we provide a short introduction to Lassoâ€™s solution to lookups - and where exactly the polynomial commitment schemes come up.</description></item><item><title>(Non-) native arithmetic in recursive proofs</title><link>https://HungryCatsStudio.github.io/posts/non-native/</link><pubDate>Mon, 22 Aug 2022 11:03:00 +0200</pubDate><guid>https://HungryCatsStudio.github.io/posts/non-native/</guid><description>As with the previous post, this isn&amp;rsquo;t intended to serve as an introduction to SNARKs, recursive proofs nor pairing-friendly curves. Rather, it&amp;rsquo;s an attempt to explain a topic that comes up often in conjunction with the aforementioned terms, namely non-native field arithmetic. I&amp;rsquo;ll first explain the why: the context of where non-native arithmetic arises. Then I will try to define the what: by comparing it to native arithmetic and describing in what part of SNARKs each of them is used.</description></item><item><title>From one {point,poly} to multi {point,poly} commitment schemes</title><link>https://HungryCatsStudio.github.io/posts/poly_commit/</link><pubDate>Mon, 01 Aug 2022 11:03:00 +0200</pubDate><guid>https://HungryCatsStudio.github.io/posts/poly_commit/</guid><description>This is my first entry here, so I would highly appreciate any feedback.
This is not an introduction to Polynomial Commitment Schemes (PCS). Instead, I will use some statements from vanilla KZG scheme and build upon these for multiple points and multiple polynomials. If you are new to PCS, I recommend the intro by Dankrad Feist or the original KZG paper.
Polynomial committment schemes The primary focus of this article is to explore various flavours of KZG polynomial commitment scheme:</description></item></channel></rss>