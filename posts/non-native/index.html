<!doctype html><html lang=en-us><head><link rel=preload href=../../lib/font-awesome/webfonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=../../lib/font-awesome/webfonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=../../lib/font-awesome/webfonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=preload href=../../lib/JetBrainsMono/web/woff2/JetBrainsMono-Regular.woff2 as=font type=font/woff2 crossorigin=anonymous><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>(Non-) native arithmetic in recursive proofs | mmagician</title><link rel=canonical href=https://mmagician.github.io/posts/non-native/><meta name=description content="Marcin GÃ³rny, `mmagician` - is a mathematician by passion and software developer by training."><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="all,follow"><meta name=googlebot content="index,follow,snippet,archive"><meta property="og:title" content="(Non-) native arithmetic in recursive proofs"><meta property="og:description" content="As with the previous post, this isn&rsquo;t intended to serve as an introduction to SNARKs, recursive proofs nor pairing-friendly curves. Rather, it&rsquo;s an attempt to explain a topic that comes up often in conjunction with the aforementioned terms, namely non-native field arithmetic. I&rsquo;ll first explain the why: the context of where non-native arithmetic arises. Then I will try to define the what: by comparing it to native arithmetic and describing in what part of SNARKs each of them is used."><meta property="og:type" content="article"><meta property="og:url" content="https://mmagician.github.io/posts/non-native/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-22T11:03:00+02:00"><meta property="article:modified_time" content="2022-08-22T11:03:00+02:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="(Non-) native arithmetic in recursive proofs"><meta name=twitter:description content="As with the previous post, this isn&rsquo;t intended to serve as an introduction to SNARKs, recursive proofs nor pairing-friendly curves. Rather, it&rsquo;s an attempt to explain a topic that comes up often in conjunction with the aforementioned terms, namely non-native field arithmetic. I&rsquo;ll first explain the why: the context of where non-native arithmetic arises. Then I will try to define the what: by comparing it to native arithmetic and describing in what part of SNARKs each of them is used."><link rel=stylesheet href=https://mmagician.github.io/css/styles.94f653e9e151e28067a7c5dbbc4600cbd5a3c721e79faaf971e523c40f3b249b8e4f20bb57810dfffa8d559ca5c140fd56eb4cd9c0853113ad08e66afdb08bdd.css integrity="sha512-lPZT6eFR4oBnp8XbvEYAy9WjxyHnn6r5ceUjxA87JJuOTyC7V4EN//qNVZylwUD9VutM2cCFMROtCOZq/bCL3Q=="><!--[if lt IE 9]><script src=https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js></script>
<script src=https://oss.maxcdn.com/respond/1.4.2/respond.min.js></script><![endif]--><link rel=icon type=image/png href=https://mmagician.github.io/images/favicon.ico></head><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.13.2/dist/katex.min.css integrity=sha384-Cqd8ihRLum0CCg8rz0hYKPoLZ3uw+gES2rXQXycqnL5pgVQIflxAUDS7ZSjITLb5 crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.2/dist/katex.min.js integrity=sha384-1Or6BdeNQb0ezrmtGeqQHFpppNd7a/gw29xeiSikBbsb44xu3uAo8c7FwbF5jhbd crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.13.2/dist/contrib/auto-render.min.js integrity=sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl crossorigin=anonymous onload=renderMathInElement(document.body)></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1,trust:e=>["\\htmlId","\\href"].includes(e.command),macros:{"\\eqref":"\\href{###1}{(\\text{#1})}","\\ref":"\\href{###1}{\\text{#1}}","\\label":"\\htmlId{#1}{}"}})})</script><body class="max-width mx-auto px3 ltr"><div class="content index py4"><div id=header-post><a id=menu-icon href=#><i class="fas fa-bars fa-lg"></i></a>
<a id=menu-icon-tablet href=#><i class="fas fa-bars fa-lg"></i></a>
<a id=top-icon-tablet href=# onclick='$("html, body").animate({scrollTop:0},"fast")' style=display:none aria-label="Top of Page"><i class="fas fa-chevron-up fa-lg"></i></a>
<span id=menu><span id=nav><ul><li><a href=../../>Home</a></li><li><a href=../../arkworks>arkworks</a></li><li><a href=../../validator>Polkadot Validator</a></li><li><a href=../../hardmathgame>Hard Math Game</a></li></ul></span><br><span id=actions><ul><li><a class=icon href=https://mmagician.github.io/posts/poly_commit/ aria-label=Previous><i class="fas fa-chevron-left" aria-hidden=true onmouseover='$("#i-prev").toggle()' onmouseout='$("#i-prev").toggle()'></i></a></li><li><a class=icon href=# onclick='$("html, body").animate({scrollTop:0},"fast")' aria-label="Top of Page"><i class="fas fa-chevron-up" aria-hidden=true onmouseover='$("#i-top").toggle()' onmouseout='$("#i-top").toggle()'></i></a></li><li><a class=icon href=# aria-label=Share><i class="fas fa-share-alt" aria-hidden=true onmouseover='$("#i-share").toggle()' onmouseout='$("#i-share").toggle()' onclick='return $("#share").toggle(),!1'></i></a></li></ul><span id=i-prev class=info style=display:none>Previous post</span>
<span id=i-next class=info style=display:none>Next post</span>
<span id=i-top class=info style=display:none>Back to top</span>
<span id=i-share class=info style=display:none>Share post</span></span><br><div id=share style=display:none><ul><li><a class=icon href="http://www.facebook.com/sharer.php?u=https%3a%2f%2fmmagician.github.io%2fposts%2fnon-native%2f" aria-label=Facebook><i class="fab fa-facebook" aria-hidden=true></i></a></li><li><a class=icon href="https://twitter.com/share?url=https%3a%2f%2fmmagician.github.io%2fposts%2fnon-native%2f&text=%28Non-%29%20native%20arithmetic%20in%20recursive%20proofs" aria-label=Twitter><i class="fab fa-twitter" aria-hidden=true></i></a></li><li><a class=icon href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2fmmagician.github.io%2fposts%2fnon-native%2f&title=%28Non-%29%20native%20arithmetic%20in%20recursive%20proofs" aria-label=Linkedin><i class="fab fa-linkedin" aria-hidden=true></i></a></li><li><a class=icon href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2fmmagician.github.io%2fposts%2fnon-native%2f&is_video=false&description=%28Non-%29%20native%20arithmetic%20in%20recursive%20proofs" aria-label=Pinterest><i class="fab fa-pinterest" aria-hidden=true></i></a></li><li><a class=icon href="mailto:?subject=%28Non-%29%20native%20arithmetic%20in%20recursive%20proofs&body=Check out this article: https%3a%2f%2fmmagician.github.io%2fposts%2fnon-native%2f" aria-label=Email><i class="fas fa-envelope" aria-hidden=true></i></a></li><li><a class=icon href="https://getpocket.com/save?url=https%3a%2f%2fmmagician.github.io%2fposts%2fnon-native%2f&title=%28Non-%29%20native%20arithmetic%20in%20recursive%20proofs" aria-label=Pocket><i class="fab fa-get-pocket" aria-hidden=true></i></a></li><li><a class=icon href="http://reddit.com/submit?url=https%3a%2f%2fmmagician.github.io%2fposts%2fnon-native%2f&title=%28Non-%29%20native%20arithmetic%20in%20recursive%20proofs" aria-label=reddit><i class="fab fa-reddit" aria-hidden=true></i></a></li><li><a class=icon href="http://www.tumblr.com/share/link?url=https%3a%2f%2fmmagician.github.io%2fposts%2fnon-native%2f&name=%28Non-%29%20native%20arithmetic%20in%20recursive%20proofs&description=As%20with%20the%20previous%20post%2c%20this%20isn%26rsquo%3bt%20intended%20to%20serve%20as%20an%20introduction%20to%20SNARKs%2c%20recursive%20proofs%20nor%20pairing-friendly%20curves.%20Rather%2c%20it%26rsquo%3bs%20an%20attempt%20to%20explain%20a%20topic%20that%20comes%20up%20often%20in%20conjunction%20with%20the%20aforementioned%20terms%2c%20namely%20non-native%20field%20arithmetic.%20I%26rsquo%3bll%20first%20explain%20the%20why%3a%20the%20context%20of%20where%20non-native%20arithmetic%20arises.%20Then%20I%20will%20try%20to%20define%20the%20what%3a%20by%20comparing%20it%20to%20native%20arithmetic%20and%20describing%20in%20what%20part%20of%20SNARKs%20each%20of%20them%20is%20used." aria-label=Tumblr><i class="fab fa-tumblr" aria-hidden=true></i></a></li><li><a class=icon href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2fmmagician.github.io%2fposts%2fnon-native%2f&t=%28Non-%29%20native%20arithmetic%20in%20recursive%20proofs" aria-label="Hacker News"><i class="fab fa-hacker-news" aria-hidden=true></i></a></li></ul></div><div id=toc><nav id=TableOfContents><ul><li><a href=#recursion>Recursion</a></li></ul><ul><li><a href=#base-field>Base field</a><ul><li><a href=#base-field-in-pairings>Base field in pairings</a></li></ul></li><li><a href=#scalar-field>Scalar field</a></li><li><a href=#scalar-field-in-circuits>Scalar field in circuits</a></li></ul></nav></div></span></div><article class=post itemscope itemtype=http://schema.org/BlogPosting><header><h1 class=posttitle itemprop="name headline">(Non-) native arithmetic in recursive proofs</h1><div class=meta><div class=postdate><time datetime="2022-08-22 11:03:00 +0200 +0200" itemprop=datePublished>22-08-2022</time></div><div class=article-read-time><i class="far fa-clock"></i>
8 minute read</div></div></header><div class=content itemprop=articleBody><p>As with the previous post, this isn&rsquo;t intended to serve as an introduction to SNARKs, recursive proofs nor pairing-friendly curves. Rather, it&rsquo;s an attempt to explain a topic that comes up often in conjunction with the aforementioned terms, namely <strong>non-native field arithmetic</strong>. I&rsquo;ll first explain the <em>why</em>: the context of where non-native arithmetic arises. Then I will try to define the <em>what</em>: by comparing it to native arithmetic and describing in what part of SNARKs each of them is used. Finally, I&rsquo;ll close with a brief summary of the techniques used for realising non-native arithmetic efficiently.</p><h1 id=non-native-arithmetic-the-why>Non-native arithmetic: the <em>why</em></h1><p>The notion of native vs. non-native arithmetic doesn&rsquo;t really arise in a non-recursive setting, such as when a prover sends a proof that encodes the entire circuit in a &ldquo;flat&rdquo; proof, and the verifier performs some pairing checks to either accept or reject the proof.</p><p>The environment where the prover algorithm runs is completely separated from the environment of the verifier. In fact, they are likely to be separate machines altogether.</p><h2 id=recursion>Recursion</h2><p>So far so good, because the parties are completely separate and don&rsquo;t need to care about one another&rsquo;s arithmetic preferences. The challenge arises when we wish to compose the proofs via recursion. For a variety of applications such as zk-rollups or incrementally verifiable computation, we might want to split the proof generation into smaller, more managable parts. An intuition would be that if the prover&rsquo;s compute and memory requirements are linearly dependant on the statement size, then for very large statements which might be computationally infeasible under direct construction, the computation is split into smaller statements and recursed. For example, rather than proving that a block in the Bitcoin network is valid by directly proving all of the state transitions since genesis in one go, we instead prove that given the previous block and the current state transition, the new block is indeed valid, and recurse back to genesis.</p><p>The overall idea of proof recursion is that the circuit doesn&rsquo;t encode the full computation (all state transitions), but rather a small part of it (single state transition), plus an additional circuit to represent the verifier <em>which runs inside the prover&rsquo;s circuit</em>. This way, a proof of the validity of some final state $S_n$ contains a proof for that final transition from $S_{n-1} -> S_n$ was computed correctly, as well as a proof that the transition to $S_{n-1}$ was valid. Of course this only makes sense if |circuit for encoding the verifier| + |circuit for the sub-statement| &lt; |circuit for the entire statement|<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>.</p><p>Here&rsquo;s the caveat: the arithmetic of the prover and the arithmetic of the verifier are performed over two different finite fields. If the prover wishes to encode the logic for the verifier within their circuit constraints, they must be able to do arithmetic over the (verifier&rsquo;s native, prover&rsquo;s non-native) $ð½_q$, rather than (prover&rsquo;s native) $ð½_r$.</p><p>If this all sounds a bit abstract, let&rsquo;s walk through some of the operations that each party performs.</p><h1 id=non-native-arithmetic-the-what>Non-native arithmetic: the <em>what</em></h1><p>To answer what non-native arithmetic is, perhaps one should start with the definition of &ldquo;native&rdquo; arithmetic.</p><h2 id=base-field>Base field</h2><p>Elliptic curves useful for cryptographic applications are usually defined over a finite field, $ð½_q$ - usually called the base field, where $q$ is prime power ($q = p^k$ for prime $p$).</p><p>This means that each point on the curve $E(ð½_q)$ has its coordinates constrained to lie within the range $[0,q)$.</p><p>E.g. let&rsquo;s take a field with $q = 47$, and a curve equation $E(ð½_q): y^2 = x^3 + 5x$.
A valid point on the curve is one which satisfies the curve equation.
One such valid element:</p><ul><li>(28, 7)</li></ul><p>But there are many tuples which do not result in a valid point on our curve ($8^2 \neq 28^3 + 5*28$ mod $47$):</p><ul><li>(28, 8)</li></ul><p>The main point here is that all arithmetic done on the curve requires reductions modulo $q$. Determining whether a point lies on the curve is just one example of such a computation.
Imagine another application, where (for reasons that will be explained later) we are given a rational function $f: E(ð½_q) \to ð½_q$ which takes as input a point on the curve $P$ and operates on its coordinates $x, y$ to output a field element. It is meaningless to perform arithmetic on coordinates $x, y \in ð½_q$ over a modulus different than $q$.</p><h3 id=base-field-in-pairings>Base field in pairings</h3><p>I will make a big leap here and jump right from the definition of the base field to elliptic curve pairings. Don&rsquo;t worry though, we will neither cover the formal definition nor all the details. In order to understand where non-native arithmetic is used in SNARKs, it is enough to accept the following:</p><ul><li>verifier must perform a pairing check $e(\cdot, \cdot) \stackrel{?}{=} e(\cdot, \cdot)$ to convince themselves of the validity of some statement</li><li>the inputs to a pairing $e$ are group elements belonging to two (potentially distinct) cryptographic groups $G_1$ and $G_2$</li><li>they are the subgroups of some $E(ð½_{q^k})$ (note that $k$ might be 1 for one or both of the groups)</li><li>arithmetic on $E(ð½_{q^k})$ is done over the field $ð½_q$ no matter the embedding degree $k$</li><li>the key subroutine of all pairings is a Miller loop: it works by iteratively applying some rational function and accumulating the result as a field element</li><li>the rational functions in the Miller loop are straight lines:<ul><li>their equation depends on the first input $P$ (from $G_1$). They define the intersection of the a line through $P$ and some multiple of $P$, with the curve $E(ð½_{q^k})$.</li><li>they are evaluated at the coordinates of the second input element $Q$ (from $G_2$).</li></ul></li></ul><p>It naturally follows that the arithmetic in the iterations of the Miller loop are performed over the base field $ð½_q$. Thus, the verifier&rsquo;s native field is the base field $ð½_q$ of the curve $E(ð½_q)$.</p><h2 id=scalar-field>Scalar field</h2><p>Before defining the scalar field, we need to define one more concept: groups.
Each set of valid elliptic curve points $E(ð½_q)$ automatically forms an abelian group $G$ under addition.
Without diving into the formalism, let&rsquo;s state some practical properties of the group $G$ that we care about here:</p><ul><li>some element of this group can generate all other group members via repeated addition of itself, call it the generator $g$</li><li>the order of the group is denoted as $n = $ #$E(ð½_q)$</li><li>each element of the group has its own order, and it divides order $n$ of the whole group</li><li>some elements have a prime order. If such an element is chosen as the generator, it will generate a <em>cyclic</em> subgroup</li><li>in fact, all elements of the cyclic subgroup are its generators</li><li>if $r$ is the order of the subgroup, then for any $g$ in the subgroup, $r \cdot g = 1$</li></ul><p>So what we are after is a subgroup $G$ of $E(ð½_q)$ with a <strong>large</strong> prime order $r$. When we define curves suitable for pairing-based cryptography (PBC), we usually specify this $r$ in the curve parameters as the size of the scalar field $ð½_r$ (alongside the previously mentioned $ð½_q$).
In practice, when working with SNARKs the data that is passed between the parties (such as the prover and the verifier) will be encoded as group elements, and the circuit representing our computation will be defined over the scalar field $ð½_r$.</p><h2 id=scalar-field-in-circuits>Scalar field in circuits</h2><p><a href=https://medium.com/@VitalikButerin/quadratic-arithmetic-programs-from-zero-to-hero-f6d558cea649>Recall</a> that in order to represent an arithmetic circuit corresponding to the statement that we wish to prove, we need to represent the circuit as a set of polynomials.</p><p>Ultimately, we would like to be able to commit to such polynomials and open them at certain points as challenged by the verifier. Interestingely, the variable of our (univariate) polynomial will assume en element of a finite field AND an element of a group.</p><p>Specifically, when we commit to a polynomial, we will output a group element, and when we open a polynomial, we will output both a field element and a group element. What really matters though, is that the order of both is $r$, mentioned in the previous section.</p><p>This boils down to the coefficients of our polynomial being in the range $[0, r)$, and so all arithmetic is performed mod $r$. Notice that it wouldn&rsquo;t be of much use to multiply a group element by something bigger than $r$, say $r+5$, since $r \cdot g = 1$, so $(r+5) \cdot g = 5 \cdot g$.</p><p>In a typical instantiation of a polynomial commitment scheme, it is the prover&rsquo;s job to caluclate the commitment of their secret polynomial, then evaluate the polynomial at a concrete challenge $z$ and send the claimed evaluation $y = p(z)$ to the verifier (together with the proof).</p><p>With this slightly informal argument we establish that the prover needs to perform work over the scalar field.</p><h1 id=non-native-arithmetic-the-how>Non-native arithmetic: the <em>how</em></h1><p>The idea of this post was to give the reader an intuition of what the terms &ldquo;native&rdquo; and &ldquo;non-native&rdquo; arithmetic mean in the context of SNARKs, without going into how they are realised in practice. It would be incomplete, however, to completely skip it, so here&rsquo;s my best attempt at summarising it in a few sentences.</p><p>To achieve recursion, we could try to simulate the non-native arithmetic inside a circuit, as a native computation. This would require splitting the large mod-q elements into smaller limbs, s.t. computation can be safely performed with the small mod-r, without the danger of &ldquo;overflowing&rdquo;. This, unfortunately, imposes a lot of overhead on the circuit and as such is inefficient in practice.</p><p>An alternative approach, pioneered in <a href=https://eprint.iacr.org/2014/595.pdf>BCTV14</a>, was the use of cycles of pairing-friendly curves<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>. The idea is that instead of having a SNARK defined over a single curve, we have two SNARKs, each defined over a separate curve, s.t. the base field of one curve is the scalar field of the other, and vice-versa. This allows for representing the verifier&rsquo;s circuit efficiently (without the overhead of simulating mod-q arithmetic with mod-r arithmetic) and the resulting protocol alternates between calling the two SNARKs.</p><h1 id=outlook>Outlook</h1><p>The advent of recent constructions such as accumulator schemes (see <a href=https://eprint.iacr.org/2019/1021.pdf>here</a> or <a href=https://eprint.iacr.org/2020/499.pdf>here</a>) or <a href=https://eprint.iacr.org/2021/370>folding schemes</a> for achieving incrementally verifiable computation might render the notion of &ldquo;(non-) native&rdquo; arithmetic somewhat obsolete. While there still exists a need to encode the verifier&rsquo; computation inside the prover&rsquo;s circuit, the scope of verifier&rsquo;s work during recursion can be greatly reduced from SNARK verification to the mentioned accumulator/folding schemes. As a result, the most expensive part of that circuit (the pairing check) disappears <sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>.</p><p>More on accumulator schemes another time.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>And if the verifier&rsquo;s computation inside the circuit doesn&rsquo;t increase in size as we recurse.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>To find out what makes a curve pairing-friendly, I refer the interested reader to <a href=https://www.craigcostello.com.au/s/PairingsForBeginners.pdf>Craig Costello&rsquo;s excellent guide to pairings</a> or <a href=https://crypto.stanford.edu/pbc/thesis.pdf>Ben Lynn&rsquo;s dissertation</a>.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>There is still a pairing to be done, but it only happens once at the end of the protocol, outside of the recursion loop.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div></article><div id=footer-post-container><div id=footer-post><div id=nav-footer style=display:none><ul><li><a href=../../>Home</a></li><li><a href=../../arkworks>arkworks</a></li><li><a href=../../validator>Polkadot Validator</a></li><li><a href=../../hardmathgame>Hard Math Game</a></li></ul></div><div id=toc-footer style=display:none><nav id=TableOfContents><ul><li><a href=#recursion>Recursion</a></li></ul><ul><li><a href=#base-field>Base field</a><ul><li><a href=#base-field-in-pairings>Base field in pairings</a></li></ul></li><li><a href=#scalar-field>Scalar field</a></li><li><a href=#scalar-field-in-circuits>Scalar field in circuits</a></li></ul></nav></div><div id=share-footer style=display:none><ul><li><a class=icon href="http://www.facebook.com/sharer.php?u=https%3a%2f%2fmmagician.github.io%2fposts%2fnon-native%2f" aria-label=Facebook><i class="fab fa-facebook fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://twitter.com/share?url=https%3a%2f%2fmmagician.github.io%2fposts%2fnon-native%2f&text=%28Non-%29%20native%20arithmetic%20in%20recursive%20proofs" aria-label=Twitter><i class="fab fa-twitter fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2fmmagician.github.io%2fposts%2fnon-native%2f&title=%28Non-%29%20native%20arithmetic%20in%20recursive%20proofs" aria-label=Linkedin><i class="fab fa-linkedin fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2fmmagician.github.io%2fposts%2fnon-native%2f&is_video=false&description=%28Non-%29%20native%20arithmetic%20in%20recursive%20proofs" aria-label=Pinterest><i class="fab fa-pinterest fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="mailto:?subject=%28Non-%29%20native%20arithmetic%20in%20recursive%20proofs&body=Check out this article: https%3a%2f%2fmmagician.github.io%2fposts%2fnon-native%2f" aria-label=Email><i class="fas fa-envelope fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://getpocket.com/save?url=https%3a%2f%2fmmagician.github.io%2fposts%2fnon-native%2f&title=%28Non-%29%20native%20arithmetic%20in%20recursive%20proofs" aria-label=Pocket><i class="fab fa-get-pocket fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://reddit.com/submit?url=https%3a%2f%2fmmagician.github.io%2fposts%2fnon-native%2f&title=%28Non-%29%20native%20arithmetic%20in%20recursive%20proofs" aria-label=reddit><i class="fab fa-reddit fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="http://www.tumblr.com/share/link?url=https%3a%2f%2fmmagician.github.io%2fposts%2fnon-native%2f&name=%28Non-%29%20native%20arithmetic%20in%20recursive%20proofs&description=As%20with%20the%20previous%20post%2c%20this%20isn%26rsquo%3bt%20intended%20to%20serve%20as%20an%20introduction%20to%20SNARKs%2c%20recursive%20proofs%20nor%20pairing-friendly%20curves.%20Rather%2c%20it%26rsquo%3bs%20an%20attempt%20to%20explain%20a%20topic%20that%20comes%20up%20often%20in%20conjunction%20with%20the%20aforementioned%20terms%2c%20namely%20non-native%20field%20arithmetic.%20I%26rsquo%3bll%20first%20explain%20the%20why%3a%20the%20context%20of%20where%20non-native%20arithmetic%20arises.%20Then%20I%20will%20try%20to%20define%20the%20what%3a%20by%20comparing%20it%20to%20native%20arithmetic%20and%20describing%20in%20what%20part%20of%20SNARKs%20each%20of%20them%20is%20used." aria-label=Tumblr><i class="fab fa-tumblr fa-lg" aria-hidden=true></i></a></li><li><a class=icon href="https://news.ycombinator.com/submitlink?u=https%3a%2f%2fmmagician.github.io%2fposts%2fnon-native%2f&t=%28Non-%29%20native%20arithmetic%20in%20recursive%20proofs" aria-label="Hacker News"><i class="fab fa-hacker-news fa-lg" aria-hidden=true></i></a></li></ul></div><div id=actions-footer><a id=menu-toggle class=icon href=# onclick='return $("#nav-footer").toggle(),!1' aria-label=Menu><i class="fas fa-bars fa-lg" aria-hidden=true></i> Menu</a>
<a id=toc-toggle class=icon href=# onclick='return $("#toc-footer").toggle(),!1' aria-label=TOC><i class="fas fa-list fa-lg" aria-hidden=true></i> TOC</a>
<a id=share-toggle class=icon href=# onclick='return $("#share-footer").toggle(),!1' aria-label=Share><i class="fas fa-share-alt fa-lg" aria-hidden=true></i> share</a>
<a id=top style=display:none class=icon href=# onclick='$("html, body").animate({scrollTop:0},"fast")' aria-label="Top of Page"><i class="fas fa-chevron-up fa-lg" aria-hidden=true></i> Top</a></div></div></div><footer id=footer><div class=footer-left>Copyright &copy; 2023 mmagician</div><div class=footer-right><nav><ul><li><a href=../../>Home</a></li><li><a href=../../arkworks>arkworks</a></li><li><a href=../../validator>Polkadot Validator</a></li><li><a href=../../hardmathgame>Hard Math Game</a></li></ul></nav></div></footer></div></body><link rel=stylesheet href=../../lib/font-awesome/css/all.min.css><script src=../../lib/jquery/jquery.min.js></script>
<script src=../../js/main.js></script>
<script src=../../js/code-copy.js></script></html>